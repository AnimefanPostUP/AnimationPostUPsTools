import bpy
import bmesh
from random import uniform
from . import bl_info
from enum import Enum
import math
import mathutils
from mathutils import Vector
from bpy.types import Menu
from bpy.types import WorkSpaceTool
from mathutils import Euler
import numpy as np
import os

import importlib.util
import re
import glob

#MODULE_EARLY_INSTALLERSPACE_START_00000000
    
#MODULE_INSTALLER_SPACE_START_IGNORE_0013000000
def rename(self, context):  return 	'file: 02_menu_pivotsetter_a.pymodule    line: 172'
def fixRotation(self, ctx):  return 	'file: 04_menu_rotationtool_op.pymodule    line: 35'
def createOptimizedUV(self, context):  return 	'file: 07_menu_uvopt_op.pymodule    line: 21'
def run_process(command):  return 	'file: 07_menu_uvopt_op.pymodule    line: 233'
def writeImagePixels(image, pixels):  return 	'file: 07_menu_uvopt_op.pymodule    line: 241'
def createImageFromPixels(pixels, width, height, name):  return 	'file: 07_menu_uvopt_op.pymodule    line: 248'
def readImagePixel_INT(imageArray, x, y, width, height):  return 	'file: 07_menu_uvopt_op.pymodule    line: 255'
def createOrReturnImage (name, width, height):  return 	'file: 07_menu_uvopt_op.pymodule    line: 261'
def getpixelgrayscaled(pixel):  return 	'file: 07_menu_uvopt_op.pymodule    line: 269'
def img_getImagePixelIndex(xt, yt, imagewidth):  return 	'file: 07_menu_uvopt_op.pymodule    line: 272'
def unpackImageArray_np(imageArray, width, height):  return 	'file: 07_menu_uvopt_op.pymodule    line: 277'
def process_completed_process(completed_process, sourceimage, targetimage, width_img, height_img):  return 	'file: 07_menu_uvopt_op.pymodule    line: 282'
    def __init__(self, mainimage, imageAverage, imageGradient, imageLines, imageDetails, imageEdges, imageOrientation, imageText):  return 	'file: 07_menu_uvopt_op.pymodule    line: 342'
def debug_write_vertex_coordinated(self, context):  return 	'file: 18_operators_debug.pymodule    line: 5'
def debug_setupBone(self, context):  return 	'file: 18_operators_debug.pymodule    line: 18'
def debug_print_vertex_withBoneAnimation(self, context):  return 	'file: 18_operators_debug.pymodule    line: 40'
def debug_print_applyAnimation(self, context):  return 	'file: 18_operators_debug.pymodule    line: 60'
def get_current_Vertcount():  return 	'file: 20_module_bl_current_obj_getters.pymodule    line: 0'
def find_most_facing_axis(vector):  return 	'file: 21_module_op_pivot.pymodule    line: 0'
def setPivot(self, context):  return 	'file: 21_module_op_pivot.pymodule    line: 17'
def setSelectionforAllObjects(selected_Objects, state):  return 	'file: 22_module_bl_selector.pymodule    line: 0'
def linear_to_sRGB(linear_value):  return 	'file: 30_module_bl_image.pymodule    line: 0'
def math_UVPosition_By_Tile(xt, yt, tile_count_x, tile_count_y):  return 	'file: 30_module_bl_image.pymodule    line: 7'
def math_PixelIndex_By_TileNumber(xt, yt, width, height, tile_count_x, tile_count_y, uv_offset_x=0, uv_offset_y=0):  return 	'file: 30_module_bl_image.pymodule    line: 26'
def math_getTileFromUVXY(tilecountx, tilecounty, x,y):      return 	'file: 30_module_bl_image.pymodule    line: 48'
def math_getTileFromUV(tilecountx, tilecounty, uv):  return 	'file: 30_module_bl_image.pymodule    line: 64'
def img_readPixel_By_Index(img, index):  return 	'file: 30_module_bl_image.pymodule    line: 80'
def readImagePixel(image, x, y):  return 	'file: 30_module_bl_image.pymodule    line: 90'
def img_getImagePixelIndex(xt, yt, imagewidth):  return 	'file: 30_module_bl_image.pymodule    line: 107'
def img_getTilesetPixelIndex(xt, yt, tilesizex):  return 	'file: 30_module_bl_image.pymodule    line: 118'
def math_getIndexByTile(xt, yt, tile_count_x):  return 	'file: 30_module_bl_image.pymodule    line: 129'
def cleanupSharpsAndSplits(self, context):  return 	'file: 40_module_bl_normals.pymodule    line: 0'
def smoothObjects(self, context):  return 	'file: 40_module_bl_normals.pymodule    line: 17'
def smoothReversedSelection(self, context):  return 	'file: 40_module_bl_normals.pymodule    line: 30'
def mergeNormals(self, context):  return 	'file: 40_module_bl_normals.pymodule    line: 36'
def splitNormals(self, context):  return 	'file: 40_module_bl_normals.pymodule    line: 43'
def rotate90DegL(self, context):  return 	'file: 50_module_bl_rotationtool.pymodule    line: 0'
def rotate90DegR(self, context):  return 	'file: 50_module_bl_rotationtool.pymodule    line: 23'
def clipRotation(self, context):    return 	'file: 50_module_bl_rotationtool.pymodule    line: 47'
def create_vertex_group(obj, group_name):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 1'
def remove_vertex_groups(obj):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 7'
def remove_vertex_groups_by_name(obj, group_name):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 13'
def add_vertex_group_to_object(obj, group_name):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 19'
def createVertexgroupIfNotExists(obj, group_name):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 30'
def createIncrementedVertexgroupIfNotExists(obj, group_name):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 34'
def applyVertexgroupToMesh(obj, group_name, vertex_indices):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 43'
def clean_other_groups(obj, groupname, changed_vertices):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 48'
def selectByGroup(self, ctx):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 57'
def select_vertices_in_group(group):  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 101'
def get_vertex_groups_from_selected():  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 139'
def get_common_vertex_groups_from_selected():  return 	'file: 70_module_bl_vertexgroups.pymodule    line: 159'
def getAllVertexIndices(obj):  return 	'file: 71_module_bl_vertexmanipulation.pymodule    line: 1'
def getPositionFromIndices(obj, vertex_indices):  return 	'file: 71_module_bl_vertexmanipulation.pymodule    line: 4'
def set_vertex_positions(obj, vertex_indices, positions):  return 	'file: 71_module_bl_vertexmanipulation.pymodule    line: 7'
def set_vertex_positions_bmesh(obj, vertex_indices, positions):  return 	'file: 71_module_bl_vertexmanipulation.pymodule    line: 11'
def set_vertex_positions_4dsafe(obj, vertex_indices, positions):  return 	'file: 71_module_bl_vertexmanipulation.pymodule    line: 33'
def createAnimation(obj, bone, transformation_matrix, last_frame):  return 	'file: 80_module_bl_animation.pymodule    line: 1'
def checkIfBoneExists(armature, bone_name):  return 	'file: 81_module_bl_armatures.pymodule    line: 4'
def getBoneifExists(armature, bone_name):  return 	'file: 81_module_bl_armatures.pymodule    line: 10'
def removeArmatureAndVertexgroups(obj, armature):  return 	'file: 81_module_bl_armatures.pymodule    line: 30'
def removeArmatureifExists(context, mesh):  return 	'file: 81_module_bl_armatures.pymodule    line: 43'
def apply_transformations(obj, armature, vertex_indices, positions):  return 	'file: 81_module_bl_armatures.pymodule    line: 52'
def createArmatureifNotExists(context, mesh):  return 	'file: 81_module_bl_armatures.pymodule    line: 95'
def createBoneifNotExists(armature, bone_name, position):  return 	'file: 81_module_bl_armatures.pymodule    line: 131'
def getPositionByAnimation_Bonespace(new_positions, obj, armature, groupbone):  return 	'file: 81_module_bl_armatures.pymodule    line: 157'
def getMatrixOfAnimation_PoseBonespace(obj, armature, groupbone):  return 	'file: 81_module_bl_armatures.pymodule    line: 199'
def revertPositionByAnimation(positions, obj, armature, groupbone):  return 	'file: 81_module_bl_armatures.pymodule    line: 221'
def convert_to_armature_space(armature, position, obj):  return 	'file: 81_module_bl_armatures.pymodule    line: 250'
def getPositionByAnimation(new_positions, obj, armature, groupbone):  return 	'file: 81_module_bl_armatures.pymodule    line: 265'
def apply_transformation_to_bone(obj, bone, transformation_matrix):  return 	'file: 81_module_bl_armatures.pymodule    line: 303'

#MODULE_INSTALLER_SPACE_END_IGNORE_0013000001



# def import_functions_from_file(file_name):
#     print("running import_functions_from_file")
#     current_directory = os.path.dirname(__file__)
#     file_path = os.path.join(current_directory, file_name)
    
#     # Load the spec and module from the file path
#     spec = importlib.util.spec_from_file_location("module.name", file_path)
#     module = importlib.util.module_from_spec(spec)
#     spec.loader.exec_module(module)
    
#     # Use regular expression to find function definitions in the module's source
#     with open(file_path, 'r') as file:
#         content = file.read()
#     function_names = re.findall(r'def\s+(\w+)\s*\(', content)
    
#     # Get the functions from the module
#     functions = {name: getattr(module, name) for name in function_names if hasattr(module, name)}
    
#     return functions




''' DEPRECATED SIDELOADER; USE MODULE INSTALL SCRIPT INSTEAD!
def import_function_from_file(file_name, function_name):
    current_directory = os.path.dirname(__file__)
    file_path = os.path.join(current_directory, file_name)

    # Load the spec and module from the file path
    spec = importlib.util.spec_from_file_location("module.name", file_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    # Import the function into the global namespace
    globals()[function_name] = getattr(module, function_name)


#Function Finder
def find_function_names(file_name):
    with open(file_name, 'r') as file:
        content = file.read()
    function_names = re.findall(r'def\s+(\w+)\s*\(', content)
    return function_names

#File Finder
def find_python_files(directory):
    file_paths = glob.glob(os.path.join(directory, "*.py"))
    file_names = [os.path.basename(path) for path in file_paths]
    return file_names

#Code Injector
def inject_code_from_file(file_name):
    with open(file_name, 'r') as file:
        code = file.read()
    exec(code, globals())
def get_vertexpositiondata_by_id(vertex_group_data, vertex_id):
(): return None
def get_vertexpositiondata_by_id(vertex_group_data, vertex_id):
(): return None

# Now you can use testfunc directly
def sideloader():

    #Functionimport:
    print("SIDELOAD START")

    #get Directory
    current_directory = os.path.dirname(__file__)
    
    addons_directory = os.path.join(current_directory, 'addons')#added for functionbuffering

    #get Python files
    files = find_python_files(current_directory)
    
    # Use os.path.join to create the full path to the file
    function_file_path = os.path.join(addons_directory, 'function_names.py')

    #fileblacklist
    fileblacklist = ["__init__.py", "auto_load.py", "animationpostupstools.py", "function_names.py", "function_names.py"]
    
    with open(function_file_path, 'w') as function_file: #added for functionbuffering
        for file in files: #Iterate Files 
            if(file in fileblacklist):
                print ("SIDELOAD filter: "+file)
                continue
            print ("SIDELOAD File: "+file)
            full_file_path = os.path.join(current_directory, file)
            functionnames=find_function_names(full_file_path) #Get Functionnames
            for function_name in functionnames: #Iterate Functionnames
                print ("SIDELOAD Function: "+file+" - "+function_name)
                #import_function_from_file(full_file_path, function_name) #Import Function
                inject_code_from_file (full_file_path) #Inject Code
                
                # Write the function name to the new file
                function_file.write(f'def {function_name}(): pass\n') #added for functionbuffering

    print ("SIDELOAD END")

#Tester
sideloader()
sideloadtester()


'''


#Generic Tools Data:

def splitNormals_dummy(self, context):
    splitNormals(self, context)

class TTB_Data_Settings(bpy.types.PropertyGroup):
    """Stores Settings"""

    extendsplitnormalmenu: bpy.props.BoolProperty(name="Expand",description="Expand more Buttons",default=True)

    direction: bpy.props.EnumProperty(
        items=[
            ('x', 'X', 'X', '', 1),
            ('xn', 'X-', 'X-', '', 2),    
            ('y', 'Y', 'Y', '', 3),
            ('yn', 'Y-', 'Y-', '', 4),    
            ('z', 'Z', 'Z', '', 5),
            ('zn', 'Z-', 'Z-', '', 6),    
        ],
        name="Which Direction",
        description="Which Direction to set the Pivot",
        default='zn'
    )
    transformspace: bpy.props.EnumProperty(
        items=[
            ('objectspace', 'Object', 'Direction by Objectspace', '', 1),
            ('worldspace', 'World', 'Direction by Worldspace', '', 2),    
            ('auto', 'Auto', 'Will Clip the Objectrotation by the most fitting Worldspace direction', '', 3),
        ],
        name="Which Direction",
        description="Which Direction to set the Pivot",
        default='objectspace'
    )   
    cleanSplitNormals : bpy.props.BoolProperty(name="Clear Split Normals", description ="Clears Split Normals before resharpening",default= False)
    autosmooth : bpy.props.BoolProperty(name="Autosmooth", description ="Sets the Objects to Smooth Automatically",default= False)
    
    #Float Property called splitangle
    splitangle : bpy.props.FloatProperty(name="Split Angle", description ="Angle to Split Normals",default= 30, min=0, max=180, update = splitNormals_dummy)





#List Of Keydata
class Bonery_UL_keydata(bpy.types.UIList):
    """UIList for displaying Keydata by object name"""
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
        # Check if the item is valid
        if item:
            # Display the object name
            layout.label(text=item.object_name)
            # Display the vertex count
            layout.label(text=f"Groups: {len(item.vertex_group_data)}")

        else:
            layout.label(text="Invalid Keydata")
            
            

#Important Getters
def get_current_keydata(context):
    """Get the current active keydata"""
    tool_data = context.scene.bonery_tools_data
    if tool_data.active_keydata < len(tool_data.key_data):
        return tool_data.key_data[tool_data.active_keydata]
    return None

def get_current_vertexgroupdata(context):
    """Get the current active vertexgroupdata"""
    tool_data = context.scene.bonery_tools_data
    if tool_data.active_keydata < len(tool_data.key_data):
        key_data = tool_data.key_data[tool_data.active_keydata]
        if key_data.active_vertexgroupdata < len(key_data.vertex_group_data):
            return key_data.vertex_group_data[key_data.active_vertexgroupdata]
    return None

def get_current_settingsdata(context):
    return bpy.context.scene.bonery_settings_data

def get_current_tooldata_renamer(context):
    return bpy.context.scene.bonery_tools_data_renamer
            
            
#List of VertexgroupData inside the selected Keydata  
class Bonery_UL_vertexgroupdata(bpy.types.UIList):
    """UIList for displaying VertexgroupData"""

    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
        # Check if the item is valid
        if item:
            # Display the vertex group ID
            layout.label(text=f"ID: {item.vertex_group_id}")
            
            # Display the name of the group
            layout.label(text=f"Name: {item.vertex_group_name}")
            
        else:
            layout.label(text="Invalid VertexgroupData")

#Panel of the Bonerytool
class AnimationfanPostUP_PT_CorePanel(bpy.types.Panel):
    """Core Panel for Bonery addon"""
    bl_label = "Core"
    bl_idname = "anifanpostuptools_PT_core_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'AnimfanPostUP'

    def draw(self, context):
        layout = self.layout
        scene = context.scene  
        
 

        keydata = get_current_keydata(context)
        vertexgroupdata = get_current_vertexgroupdata(context)
        
        settingsdata = get_current_settingsdata(context)
        
        if keydata is not None:
            
            row = layout.row()
            
            row = layout.row()
            row.label(text="Keys:")
            row = layout.row()
            row.template_list("Bonery_UL_keydata", "", scene.bonery_tools_data, "key_data", scene.bonery_tools_data, "active_keydata")
        
            
            row.label(text="Data")
            row = layout.row()
            row.template_list("Bonery_UL_vertexgroupdata", "", keydata, "vertex_group_data", keydata, "active_vertexgroupdata")
            
           
        row = layout.row()    
        # row.operator(Bonery_OT_keymesh.bl_idname, text="Key")
        row.operator(Bonery_OT_keyparent.bl_idname, text="Parent")
        row.operator(Bonery_OT_keyloose.bl_idname, text="Key")
        
        row = layout.row()
        row.prop(settingsdata, "flicktimeline")
        
        if(settingsdata.debuggingsubmenu):
            row = layout.box()
            row.operator(Bonery_OT_printcoordinates.bl_idname, text="Print Coordinates").operationtype=0
            row.operator(Bonery_OT_printcoordinates.bl_idname, text="Setup Bone").operationtype=1
            row.operator(Bonery_OT_printcoordinates.bl_idname, text="Print Animated Coordinates").operationtype=2
            row.operator(Bonery_OT_printcoordinates.bl_idname, text="Apply Animation").operationtype=3
            row.operator(Bonery_OT_printcoordinates.bl_idname, text="Print Coordinates").operationtype=4
            row.operator(Bonery_OT_printcoordinates.bl_idname, text="Print Coordinates").operationtype=5
            row.operator(Bonery_OT_sideloaderrecall.bl_idname, text="Sideloader Recall")


class Bonery_OT_printcoordinates(bpy.types.Operator):
    """Operator to print the vertex positions of the selected object"""
    bl_idname = "bonery.print_coordinates"
    bl_label = "Print Vertex Coordinates"
    operationtype : bpy.props.IntProperty(name="operationtype", default=0)
    
    def execute(self, context):
        if self.operationtype == 0:
            print("Operationtype 0")
            debug_write_vertex_coordinated(self, context)
            
        if self.operationtype == 1:
            print("Operationtype 1")
            debug_setupBone(self, context)
            
        if self.operationtype == 2:
            print("Operationtype 2")
            debug_print_vertex_withBoneAnimation(self, context)
            
        if self.operationtype == 3:
            print("Operationtype 3")
            debug_print_applyAnimation(self, context)
            
        if self.operationtype == 4:
            print("Operationtype 4")
            debug_write_vertex_coordinated(self, context)
        
        if self.operationtype == 5:
            print("Operationtype 4")
            testfunc()
        
        return {'FINISHED'}

#Change Detection    
def detect_vertexchanges_of_group( keydata_previous, keydata_current, group_name):
    """Find all vertices inside the group that have changed and return their indices and old, new positions"""
    changed_vertices = {
        "vertex_indices": [],
        "old_positions": [],
        "new_positions": []
        }
    epsilon = 1e-6  # Define a small threshold
    
    if keydata_previous and keydata_current:
        previous_group = None
        current_group = None
        for group in keydata_previous.vertex_group_data:
            if group.vertex_group_name == group_name:
                previous_group = group
                break
        for group in keydata_current.vertex_group_data:
            print("Comparing Group: "+ group.vertex_group_name)
            if group.vertex_group_name == group_name:
                current_group = group
                break
        if previous_group and current_group:
            previous_vertices = {v.vertex_id: Vector(v.vertex_position) for v in previous_group.vertex_position_data}
            current_vertices = {v.vertex_id: Vector(v.vertex_position)for v in current_group.vertex_position_data}
            for vertex_id in current_vertices:
                if vertex_id in previous_vertices:
                    diff = current_vertices[vertex_id] - previous_vertices[vertex_id]
                    if not all(abs(d) < epsilon for d in diff):
                        print("Detected Changes: "+str(len (changed_vertices)))
                        changed_vertices["vertex_indices"].append(vertex_id)
                        changed_vertices["old_positions"].append(previous_vertices[vertex_id])
                        changed_vertices["new_positions"].append(current_vertices[vertex_id])
    return changed_vertices

def create_Keydata_by_object(context, obj):
    """Create a new keydata for the given object"""
    tool_data = context.scene.bonery_tools_data 
    key_data = tool_data.key_data.add()
    key_data.object_name = obj.name
    key_data.object_id = obj.name

    # Set index
    tool_data.active_keydata = len(tool_data.key_data) - 1
    
    # Add a group with the name "root_base"
    create_vertex_group(obj, "root_base")
    
    return key_data

def writeKeydata(keydata):
    """Write the keydata to the object"""
    obj = bpy.data.objects[keydata.object_name]
    
    # Clear existing vertex group data
    keydata.vertex_group_data.clear()
    
    groupcreated = False
    

        
    # Iterate over all vertices
    for vertex in obj.data.vertices:
        vertex_index = vertex.index

        if groupcreated: 
            obj.vertex_groups["root_base"].add([vertex_index], 1.0, 'REPLACE')
        
        # Iterate over all vertex groups
        if len (vertex.groups) <= 0 and not groupcreated:
            create_vertex_group(obj, "root_base")
            groupcreated = True
        
        for group in vertex.groups:
            group_index = group.group
            group_name = obj.vertex_groups[group_index].name
            
            #get vertex group data if it exists
            vertex_group_data = get_vertexgroupdata_by_name(keydata, group_name)
            
            # Create new vertex group data if it doesn't exist
            if vertex_group_data is None:
                vertex_group_data = create_for_vertexgroupdata(keydata, group_name)
            
            # Store vertex position data
            vertex_position_data =  create_vertexpositiondata(vertex_group_data, vertex_index, vertex.co)


#Viewport Modes

def armaturePosMode(armature, obj):
    # Check if armature is an Armature object
    if armature.type != 'ARMATURE':
        return None

    # Set the armature as the active object and switch to edit mode
    
    # Switch to pose mode to access the pose bones
    bpy.ops.object.mode_set(mode='OBJECT')
    bpy.ops.object.select_all(action='DESELECT')
    obj.select_set(True)
    bpy.context.view_layer.objects.active = armature
    bpy.ops.object.mode_set(mode='POSE')    

def objectEditMode(obj):
    bpy.ops.object.mode_set(mode='OBJECT')            
    bpy.ops.object.select_all(action='DESELECT')
    obj.select_set(True)
    bpy.context.view_layer.objects.active = obj     
    bpy.ops.object.mode_set(mode='EDIT')    

#Functions for

def copyAnimation(source_bone, target_bone, obj, armature):
    """Copy the keyframe animation from the source bone to the target bone"""

    if armature.type != 'ARMATURE':
        raise None

    if obj.pose:

        armaturePosMode(armature, obj)

        # Get the pose bones corresponding to the source and target bones
        source_pose_bone = obj.pose.bones.get(source_bone.name)
        target_pose_bone = obj.pose.bones.get(target_bone.name)

        # Check if the pose bones exist
        if source_pose_bone and target_pose_bone:
            # Copy the keyframe animation from the source bone to the target bone
            target_pose_bone.animation_data.action = source_pose_bone.animation_data.action

            print(f"Keyframe animation copied from {source_bone.name} to {target_bone.name}.")
        else:
            print("Source or target bone does not exist.")




#Creates new Vertexgroup with Bone, tool to create subgroups of vertexgroups (used for testing)
def key_newBone(context):
    # Get the active object
    obj = bpy.context.active_object
    
    # Get the selected vertices
    selected_vertices = [v for v in obj.data.vertices if v.select]
    
    # Check if any vertices are selected
    if len(selected_vertices) == 0:
        return
    
    # Calculate the center of the selected vertices
    center = calculateCenterOfPoints([v.co for v in selected_vertices])
    
    # Create a new bone centered in the middle of the vertices
    bone_name = "new_bone"
    bone = createBoneifNotExists(obj, bone_name, center)
    
    # Get the existing vertex group name
    existing_vertex_group_name = obj.vertex_groups.active.name
    
    # Create a new vertex group with the suffix "_sub" and add the vertices
    vertex_group_name = existing_vertex_group_name + "_sub"
    create_vertex_group(obj, vertex_group_name)
    vertex_group = get_vertexgroupdata_by_name(get_current_vertexgroupdata(context), vertex_group_name)
    for vertex in selected_vertices:
        create_vertexpositiondata(vertex_group, vertex.index, vertex.co)
    
    # Parent the bone if the previous vertex group had a bone
    previous_vertex_group_name = None
    current_vertex_group_name = vertex_group_name
    vertex_groups = obj.vertex_groups
    for group in vertex_groups:
        if group.name != current_vertex_group_name:
            previous_vertex_group_name = group.name
            break
    
    if previous_vertex_group_name:
        parent_bone_name = previous_vertex_group_name
        parent_bone = getBoneifExists(obj.data, parent_bone_name)
        if parent_bone:
            copyAnimation(parent_bone, bone, obj, obj.data)
    
    # Remove the previous vertex group
    remove_vertex_groups_by_name(obj, previous_vertex_group_name)

#Creation of Vertexgroups, Armatures, Bones, Automatic tool for all in one
def key_object_loose(context):
    #get the active object
    obj = bpy.context.active_object
    alreadyExisted = False
    
    #exit editmode
    bpy.ops.object.mode_set(mode='OBJECT')
    
    #get or create keydata from object
    keydata_index = get_keydata_index_by_object_name(context, obj.name)                 
            
    if keydata_index != -1:
        alreadyExisted=True
        keydata_old = context.scene.bonery_tools_data.key_data[keydata_index]
        
        vertex_position_data_indices = [vpd.vertex_id for vpd in keydata_old.vertex_group_data[0].vertex_position_data]
        
        # Iterate over vertices that have a group contained in keydata_old but no vertex_position_data
        for vertex in obj.data.vertices:
            if not vertex.groups and vertex.index in vertex_position_data_indices:
                # Remove the vertex group from the object
                obj.vertex_groups.remove(obj.vertex_groups[keydata_old.vertex_group_data[0].vertex_group_name].index)
    
    # Add "root_base" vertex group if not exists
    if "root_base" not in obj.vertex_groups:
        obj.vertex_groups.new(name="root_base")

        
        # Iterate over vertices and apply "root_base" vertex group if not already assigned
        for vertex in obj.data.vertices:
            if not vertex.groups:
                obj.vertex_groups["root_base"].add([vertex.index], 1.0, 'REPLACE')
                
    keydata = create_Keydata_by_object(context, obj) 
    writeKeydata(keydata)

    if (alreadyExisted):
        
        # Get the selected vertices
        selected_vertices = [v for v in obj.data.vertices if v.select]

        selected_groups = []
        for vertex in selected_vertices:
            for group in vertex.groups:
                group_name = obj.vertex_groups[group.group].name
                if group_name not in selected_groups:
                    selected_groups.append(group_name)


        print(str(selected_groups))

        for selectedgroup in selected_groups:
            group=get_vertexgroupdata_by_name(keydata, selectedgroup)
            
            if(not group):
                continue
            
            #if (group.name == "root_base"):
                #continue         
            
            changed_vertices = detect_vertexchanges_of_group (keydata_old, keydata, group.vertex_group_name)
            
            if changed_vertices:
                if len(changed_vertices["vertex_indices"]) > 0:
                    
                    
                    # Iterate over vertex groups and remove "root_base" from vertices in vertex_indices
                    for vertex_group in obj.vertex_groups:
                        if vertex_group.name == "root_base":
                            for vertex_id in changed_vertices["vertex_indices"]:
                                obj.vertex_groups[vertex_group.name].remove([vertex_id])
                            break
                    
                    #Extract Data
                    vertex_indices = changed_vertices["vertex_indices"]
                    old_positions = changed_vertices["old_positions"]
                    new_positions = changed_vertices["new_positions"]
            
                    #create armature if not exists
                    armature = createArmatureifNotExists(context, obj)    
                        
                    #Pre Init Positions    
                    animatedpositions_new=new_positions
                    animatedpositions_old=old_positions
                                      
                    #If Object is already Animated this Block Fixes Transformations
                    if armature and armature.type == 'ARMATURE':
                        print("Check For: " + group.vertex_group_name)
                        bone= getBoneifExists(armature,group.vertex_group_name)
                        if bone:
                            print("Bone Exists Already, transforming Data")

                            

                            #Center locations for Animation Transformation
                            src_pivot = calculateCenterOfPoints(old_positions)
                            dst_pivot = calculateCenterOfPoints(new_positions)
                                
                            oldpos_centered = old_positions - src_pivot
                            newpos_centered = new_positions - dst_pivot

                            #Counteranimated
                            if(bone):
                                print (str(new_positions))
                                animatedpositions_new=getPositionByAnimation_Bonespace(new_positions, obj, armature, bone) 
                                animatedpositions_old=getPositionByAnimation_Bonespace(old_positions, obj, armature, bone)
                                print (str(animatedpositions_new))
                                
                                # #Overwrite Positions in Group
                                # for i, vertex_id in enumerate(changed_vertices["vertex_indices"]):
                                #     vertex_position_data = get_vertexpositiondata_by_id(group, vertex_id)
                                #     if vertex_position_data:
                                #         vertex_position_data.position = animatedpositions_new[i]
        
                        else:
                            print(f"No bone named {group.vertex_group_name} found.")

                        
                    allvertschanged = len(changed_vertices["vertex_indices"]) == len(group.vertex_position_data)          
                                                                                                 
                    transformation_matrix, src_center, dst_center= calculate_vertex_transformation(animatedpositions_old, animatedpositions_new)  
         
                    transformationM, src_c, dst_c= calculate_vertex_transformation(old_positions, new_positions)  

                        
                    # print new and old matrix
                    print("Detected Transformation:")
                    print(transformation_matrix)                         
                                            
                    objectEditMode(obj)                  
                    
                    armaturespacepos=convert_to_armature_space( armature, src_center, obj)         
                    
         
                    if(not allvertschanged):
                        print("Splitting Group, creating new Vertex Group...")
                        counter = 1
                        new_group_name = group.vertex_group_name + "_sub"
                        while new_group_name in [vg.name for vg in obj.vertex_groups]:
                            new_group_name = f"{group.vertex_group_name}_sub{counter}"
                            counter += 1
                                     
                        new_vertex_group_data = create_for_vertexgroupdata(keydata, new_group_name) 
                        bone = createBoneifNotExists(armature, group.vertex_group_name, armaturespacepos)         
                        
                        # # Apply bone animation to changed vertices
                        # for i, vertex_id in enumerate(changed_vertices["vertex_indices"]):
                        #     vertex_position_data = get_vertexpositiondata_by_id(group, vertex_id)
                        #     if vertex_position_data:
                        #         vertex_position_data.position = animatedpositions_new[i]
                        #         old_positions[i] = old_positions[i]
                        #         new_positions[i] = new_positions[i]
                        
                        # #Overwrite changed vertices in the actual Blender vertex group
                        # for i, vertex_id in enumerate(changed_vertices["vertex_indices"]):
                        #     vertex_position_data = get_vertexpositiondata_by_id(group, vertex_id)
                        #     if vertex_position_data:
                        #         vertex_position_data.position = new_positions[i]
                        #         old_positions[i] = new_positions[i]
       
                        
                    else:
                        new_vertex_group_data = group
                        
                        
                    if(not allvertschanged):
                        objectEditMode(obj)
                       
                        
                    # Remove changed vertices from the old vertex group
                    if not allvertschanged:
                        bpy.ops.object.mode_set(mode='OBJECT') 
                        old_vertex_group_data = get_vertexgroupdata_by_name(keydata, group.vertex_group_name)
                        if old_vertex_group_data:
                            for vertex_id in changed_vertices["vertex_indices"]:
                                vertex_position_data = get_vertexpositiondata_by_id(old_vertex_group_data, vertex_id)
                                if vertex_position_data:
                                    for i, vpd in enumerate(old_vertex_group_data.vertex_position_data):
                                        if vpd == vertex_position_data:
                                            print("Removed Vertex from Group")
                                            break
                                        
                        # Iterate over vertex groups and remove vertices from all other groups
                        for vertex_group in obj.vertex_groups:
                            if vertex_group.name != new_vertex_group_data.vertex_group_name:
                                for vertex_id in changed_vertices["vertex_indices"]:
                                    obj.vertex_groups[vertex_group.name].remove([vertex_id])
                        clean_other_groups(obj, new_vertex_group_data.vertex_group_name, changed_vertices["vertex_indices"])
                    
                    

                               
                    if( not allvertschanged):
                        #Add new vertex group to the object
                        create_vertex_group(obj, new_group_name)
                        
                        #set the new vertex group
                        obj.vertex_groups[new_group_name].add(changed_vertices["vertex_indices"], 1.0, 'REPLACE')
                    
                    settingsdata = get_current_settingsdata(context)
                    if(settingsdata.flicktimeline):
                        bpy.context.scene.frame_current=bpy.context.scene.frame_current+10

                    armaturePosMode(armature, obj)
                    groupbone = createBoneifNotExists(armature, new_vertex_group_data.vertex_group_name, armaturespacepos)                   
                    createAnimation(obj, groupbone, transformation_matrix, new_vertex_group_data.last_frame)
                    new_vertex_group_data.last_frame = bpy.context.scene.frame_current  # Set the last frame to the current frame of the timeline
                    objectEditMode(obj)
                    
                    #Reset the vertex positions
                    set_vertex_positions_bmesh(obj, vertex_indices, old_positions )             
                        
                    bpy.context.view_layer.update()
                    writeKeydata(keydata)
                    break
        
        remove_keydata(keydata_old, context)
        
      
    objectEditMode(obj)




#Operators

class Bonery_OT_keymesh(bpy.types.Operator):
    """Operator for Bonery addon"""
    bl_idname = "bonery.keymesh"
    bl_label = "Key"

    def execute(self, context):      
        return {'FINISHED'}
    
class Bonery_OT_keyparent(bpy.types.Operator):
    """Operator for Bonery addon"""
    bl_idname =  "bonery.keyparent"
    bl_label = "Key"

    def execute(self, context):      
        key_newBone(context)
        return {'FINISHED'}
    
class Bonery_OT_keyloose(bpy.types.Operator):
    """Operator for Bonery addon"""
    bl_idname =  "bonery.keyloose"
    bl_label = "Key"

    def execute(self, context):      
        key_object_loose(context)
        return {'FINISHED'}
    
    
    
   
 #Data Classes  
    
class Bonery_OT_sideloaderrecall(bpy.types.Operator):
    """Operator for Bonery addon"""
    bl_idname =  "bonery.sideloader_recall"
    bl_label = "Sideloader Recall"

    def execute(self, context):      
        sideloader()
        return {'FINISHED'}    
    
class VertexPositionData(bpy.types.PropertyGroup):
    """Data for storing vertex positions"""
    vertex_position: bpy.props.FloatVectorProperty(name="Vertex Position")
    vertex_id: bpy.props.IntProperty(name="Vertex ID")

class VertexGroupData(bpy.types.PropertyGroup):
    """Data for storing vertex group IDs"""
    vertex_group_id: bpy.props.IntProperty(name="Vertex Group ID")
    vertex_group_name: bpy.props.StringProperty(name="Vertex Group ID")
    vertex_position_data: bpy.props.CollectionProperty(type=VertexPositionData, name="Vertex Position Data")
    parentId : bpy.props.IntProperty(name="Parent ID", default=-1)
    parentName : bpy.props.StringProperty(name="Parent Name", default="")
    last_frame: bpy.props.IntProperty(name="Last Frame", default=-1)

class Keydata(bpy.types.PropertyGroup):
    """Data for storing key information"""
    vertex_group_data: bpy.props.CollectionProperty(type=VertexGroupData, name="Vertex Group Data")
    object_name: bpy.props.StringProperty(name="Object Name", default="")
    object_id: bpy.props.StringProperty(name="Object ID", default="")
    active_vertexgroupdata : bpy.props.IntProperty(name="Active Index", default=0)
    
    
#Settings Data
class Settingsdata(bpy.types.PropertyGroup):
    """Settings for Bonery addon"""
    my_property: bpy.props.StringProperty(name="My Property")
    flicktimeline: bpy.props.BoolProperty(name="Flick Timeline",description="Enable or disable flicking the timeline",default=True)

    debuggingsubmenu: bpy.props.EnumProperty(
        items=[
            ('none', 'None', 'Hide Menus'),
            ('vertexprint', 'Vertex Print', 'Print Vertexpositions'),
            ('a', 'A', 'xxx'),
            ('b', 'B', 'xxx'),
            ('c', 'C', 'xxx'),
            ('d', 'D', 'xxx'),
            ('e', 'E', 'xxx'),
            ('f', 'F', 'xxx'),
            
        ],
        name="debugmenu",
        description="Which type of Debugging Menu to use",
        default='none'
    )

    
class Tooldata(bpy.types.PropertyGroup):
    """Tool storage for Bonery module"""
    my_tool: bpy.props.PointerProperty(type=bpy.types.Object, name="My Tool")
    key_data: bpy.props.CollectionProperty(type=Keydata, name="Key Data")
    active_keydata : bpy.props.IntProperty(name="Active Index", default=0)


class Tooldata_Renamer(bpy.types.PropertyGroup):
    """Tool storage for Renamer module"""
    Prefix : bpy.props.StringProperty(name="Prefix", default="")
    Suffix : bpy.props.StringProperty(name="Suffix", default="")


#Function Importer

#MODULE_INSTALLER_SPACE_START_00000000

#MODULE_INSTALLER_SPACE_END_00000001

#region <Utility> <Methods>
def register():
    
    
    """ !METHOD!
    Registrates Elements, may be used Different than usual due to the auto_load.py

    Keyword arguments:
    -
    """
    # Add property groups to scene
    #setattr(bpy.types.Scene, "uv_palettes_settings_data", bpy.props.PointerProperty(name="UV Palettes settings data", type=UVC_Data_Settings))
    setattr(bpy.types.Scene, "bonery_settings_data", bpy.props.PointerProperty(name="UV Palettes settings data", type=Settingsdata))
    setattr(bpy.types.Scene, "bonery_tools_data", bpy.props.PointerProperty(name="UV Palettes settings data", type=Tooldata))
    setattr(bpy.types.Scene, "bonery_tools_data_renamer", bpy.props.PointerProperty(name="UV Palettes settings data", type=Tooldata_Renamer))
    setattr(bpy.types.Scene, "bonery_vertex_group_data", bpy.props.PointerProperty(name="UV Palettes settings data", type=VertexGroupData))
    setattr(bpy.types.Scene, "bonery_vertex_position_data", bpy.props.PointerProperty(name="UV Palettes settings data", type=VertexPositionData))
    #Generic Tools
    setattr(bpy.types.Scene, "ttb_settings_data", bpy.props.PointerProperty(name="Generic Tools settings data", type=TTB_Data_Settings))

    # tool_auto_group_selector
    # AutoGroupSelector
    
    #Register the tool using setattribute
    #setattr(bpy.types, "tool_auto_group_selector", AutoGroupSelector)
    bpy.utils.register_tool(AutoGroupSelector, after={"builtin.select_box"})
    bpy.utils.register_tool(AutoGroupSelectorObject, after={"builtin.select_box"})


# Ignore section


# def import_functions_from_file(file_name):
#     print("running import_functions_from_file")
#     current_directory = os.path.dirname(__file__)
#     file_path = os.path.join(current_directory, file_name)
    
#     # Load the spec and module from the file path
#     spec = importlib.util.spec_from_file_location("module.name", file_path)
#     module = importlib.util.module_from_spec(spec)
#     spec.loader.exec_module(module)
    
